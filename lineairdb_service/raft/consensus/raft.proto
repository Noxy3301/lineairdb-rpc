syntax = "proto2";

package Raft.Protocol;

// Identifies which RPC is being invoked
enum OpCode {
    REQUEST_VOTE = 1;
    APPEND_ENTRIES = 2;
}

// Server
message Server {
    required uint64 server_id = 1;  // server id
    required string address = 2;    // server address
}

// Server list
message Servers {
    repeated Server servers = 1;
}

// Stable or transitional configuration
message Configuration {
    required Servers prev_configuration = 1;    // stable or previous configuration
    optional Servers next_configuration = 2;    // next configuration
}

// Entry type
enum EntryType {
    UNKNOWN = 0;        // default entry type (never assigned explicitly)
    CONFITURATION = 1;  // storas a configuration (used internally)
    DATA = 2;           // stoes a command for state machine
    NOOP = 3;           // no operation entry
}

// Log entry
message Entry {
    required uint64 term = 1;                   // term when entry was created
    optional EntryType type = 2;                // entry type
    optional Configuration configuration = 3;   // configuration entry (used internally) 
    optional bytes data = 4;                    // command for the state machine
    optional uint64 index = 5;                  // entry index
    required uint64 cluster_time = 6;           // approximate leader uptime in nanoseconds
}

// RequestVote RPC
message RequestVote {
    message Request {
        required uint64 server_id = 1;      // candidate's id
        required uint64 term = 2;           // candidate's term
        required uint64 last_log_index = 3; // index of candidate's last log entry
        required uint64 last_log_term = 4;  // term of candidate's last log entry
        required uint64 epoch = 5;          // logical timestamp when this request was send
    }

    message Response {
        required uint64 term = 1;            // follower's term
        required bool vote_granted = 2;      // true if follower granted vote
        required uint64 epoch = 3;           // request's epoch for tracking freshness
    }
}

// AppendEntries RPC
message AppendEntries {
    message Request {
        required uint64 server_id = 1;      // leader's id
        required uint64 term = 2;           // leader's term
        required uint64 prev_log_index = 3; // index of log entry before new entries, or last log index for heartbeat
        required uint64 prev_log_term = 4;  // term of prev_log_index entry
        repeated Entry entries = 5;         // entries to append
        required uint64 commit_index = 6;   // last commited entry index
        required uint64 epoch = 7;          // logical timestamp when this request was send
        required uint64 num_entries = 8;    // [RPC context] for correct matchIndex() update across RPC boundaries
    }

    message Response {
        required uint64 term = 1;           // follower's term
        required bool success = 2;          // true if log entries ware appended
        required uint64 last_log_index = 3; // follower's last log index after applying entries
        required uint64 epoch = 4;          // request's epoch for tracking freshness
        required uint64 prev_log_index = 5; // [RPC context] echoes request for correct matchIndex() update across RPC boundaries
        required uint64 num_entries = 6;    // [RPC context] echoes request for correct matchIndex() update across RPC boundaries
    }
}